<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frank the Obscure</title>
    <description>无名的弗兰克</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 01 Feb 2016 22:49:57 +0800</pubDate>
    <lastBuildDate>Mon, 01 Feb 2016 22:49:57 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>2015 小结</title>
        <description>&lt;p&gt;一年匆匆过去, 简单记下几笔, 纪念这一年的时光.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;读书&lt;/h2&gt;

&lt;p&gt;非虚构阅读值得留下一些记录与分享:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一月 &lt;a href=&quot;http://book.douban.com/subject/6687032/&quot;&gt;经验的疆界&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;二月 &lt;a href=&quot;http://book.douban.com/subject/20428922/&quot;&gt;学会提问-Asking the right questions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;三月 &lt;a href=&quot;http://book.douban.com/subject/25724948/&quot;&gt;黑客与画家&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;四月 &lt;a href=&quot;http://book.douban.com/subject/3609132/&quot;&gt;把时间当作朋友&lt;/a&gt; &lt;a href=&quot;https://frank-the-obscure.gitbooks.io/reading-notes/content/time-as-your-friend.html&quot;&gt;我的笔记&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;六月 &lt;a href=&quot;http://book.douban.com/subject/6509801/&quot;&gt;Flow&lt;/a&gt; &lt;a href=&quot;https://frank-the-obscure.gitbooks.io/reading-notes/content/flow.html&quot;&gt;我的笔记&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;七月 &lt;a href=&quot;http://book.douban.com/subject/3669408/&quot;&gt;身份的焦虑&lt;/a&gt; &lt;a href=&quot;http://frank-the-obscure.me/2015/07/26/status-anxiety/&quot;&gt;我的笔记&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;八月 &lt;a href=&quot;http://book.douban.com/subject/22994632/&quot;&gt;成功，动机与目标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几点体会:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读书本身乐趣甚多: 并且深度远比碎片阅读好. 因此今后不妨多读书, 压榨部分碎片时间到更大的收获上面.&lt;/li&gt;
  &lt;li&gt;道理知易行难: 读书时很容易有所感, 也有很多想要行动的具体事情. 不过在更长时间维度看结果时, 却发现很多预想通常不能成真. 问题或许在于”知”与”行”的差距. 做事看似很容易, 真正行动时, 也确实不需要什么超人的智慧, 但却常常需要极大的&lt;em&gt;耐心&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新年如有时间, 每月一本书值得坚持.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;心智&lt;/h2&gt;

&lt;p&gt;多年的理性思维训练, 慢慢积累成了一系列系统的观点(所谓的”世界观”?). 累积成文, 就成了&lt;a href=&quot;https://www.gitbook.com/book/frank-the-obscure/for-myself-at-16/details&quot;&gt;&lt;em&gt;致十六岁的自己&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这些理解, 虽然”并没有什么用”, 却是存在与思考的证明.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;编程&lt;/h2&gt;

&lt;p&gt;借着 &lt;a href=&quot;https://github.com/Frank-the-Obscure/omooc-pythoncamp0&quot;&gt;OMOOC Pythoncamp0&lt;/a&gt; 的机会, 多年之后又写起了代码. &lt;a href=&quot;https://github.com/Frank-the-Obscure/iDoulist&quot;&gt;iDoulist&lt;/a&gt; 作为和小伙伴们一起完成的作品, 也是自己第一次的工程尝试(~2000 行)&lt;/p&gt;

&lt;p&gt;后续又借着&lt;a href=&quot;https://tianchi.aliyun.com/&quot;&gt;天池大赛&lt;/a&gt;算是入了数据科学和机器学习的坑, 学了 Angrew Ng 著名的 &lt;a href=&quot;https://www.coursera.org/learn/machine-learning/&quot;&gt;Machine learning&lt;/a&gt;, 也是很快乐的学习经历.&lt;/p&gt;

&lt;p&gt;学习中, 最大的感想是学习&lt;em&gt;本身&lt;/em&gt;的乐趣相当让人满足. 看来学习作为一种娱乐方式, 也是十分可行的:)&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;年关之所以引起诸多思绪, 可能是由于它连接着过去和未来.&lt;/p&gt;

&lt;p&gt;过去的一切在此刻盖棺论定, 引来颇多感慨; 而未来也在此刻开始, 承载着美好的希望与无尽的可能性.&lt;/p&gt;

&lt;p&gt;回顾与展望之后, 只有现在的行动才真正连接可能的未来. 加油前行, 新年快乐.&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jan 2016 07:25:00 +0800</pubDate>
        <link>/2016/01/01/2015conclusions/</link>
        <guid isPermaLink="true">/2016/01/01/2015conclusions/</guid>
        
        
        <category>小结</category>
        
        <category>随笔</category>
        
      </item>
    
      <item>
        <title>Vim 入门小记</title>
        <description>&lt;h1 id=&quot;vim---chaos-to-vim&quot;&gt;Vim 入门小记 / Chaos to vim&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Outline: raw notes from chaos to vim&lt;/li&gt;
  &lt;li&gt;why vim? 为什么用 vim?&lt;/li&gt;
  &lt;li&gt;basic commands&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-vim&quot;&gt;Why vim?&lt;/h2&gt;

&lt;p&gt;其实, 最简单的原因, 是没钱买 Sublime Text, 看交钱提醒看烦了…&lt;/p&gt;

&lt;p&gt;追溯到大一时候的计概课, 曾玩过 Emacs (那是遥远的2007年了), 不过 vi/vim 一直没试过. 所以, 奇怪的下了决定开始折腾一番:)&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;入门小记&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;三种模式: 与 Emacs 的各种风骚快捷键不同, vi 通过不同的模式进行操作.
    &lt;ul&gt;
      &lt;li&gt;normal mode: 操作 各种模式下 esc 均可进入&lt;/li&gt;
      &lt;li&gt;insert mode: 输入, normal mode 下 i R a A&lt;/li&gt;
      &lt;li&gt;command mode: 复杂命令, 如保存, 退出等.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;光标移动: normal mode 下
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hjkl&lt;/code&gt; 分别是四个基本光标移动操作&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c-f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c-b&lt;/code&gt; 上下翻页&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 分别是移动到本行开头和最后&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;G&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gg&lt;/code&gt;, #line g&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;打开, 保存与退出
    &lt;ul&gt;
      &lt;li&gt;在终端中, &lt;code class=&quot;highlighter-rouge&quot;&gt;vi [filename]&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;在vi 中, &lt;code class=&quot;highlighter-rouge&quot;&gt;:e&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;保存: &lt;code class=&quot;highlighter-rouge&quot;&gt;:w&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;退出不保存: &lt;code class=&quot;highlighter-rouge&quot;&gt;:q&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;退出并保存: &lt;code class=&quot;highlighter-rouge&quot;&gt;:x&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;:wq&lt;/code&gt; (二者的区别是:x 只在文件变化时更新修改时间, :wq 则总会更新修改时间)&lt;/li&gt;
      &lt;li&gt;退出并放弃修改: &lt;code class=&quot;highlighter-rouge&quot;&gt;:q!&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;下一步&lt;/h2&gt;

&lt;p&gt;总算可以开始用了(终于不像以前误入 vi 都不会退出了), 下面, 正如 vimtutor 所言, 只有在用中学才是科学的, 那么以后 Markdown (比如这篇)也要试着用 vi 来写喽 XD&lt;/p&gt;

&lt;p&gt;另外, 命令不是用来背的, 在 Git cheat sheet 背面手写了 Vim cheat sheet 作为备忘录 :)&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;vim tutor: &lt;code class=&quot;highlighter-rouge&quot;&gt;vimtutor&lt;/code&gt; in terminal&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://linux.vbird.org/linux_basic/0310vi.php&quot;&gt;鸟哥的 vim 介绍&lt;/a&gt;: cheat sheet 部分主要记录了鸟哥图中的命令&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/spf13/spf13-vim&quot;&gt;spf13-vim @ GitHub&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;这里是一个 vim 的配置版本, 暂时先用着, 毕竟自己从零开始配置 .vimrc 还是有些太折腾了(重点是其实不会折腾)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 25 Dec 2015 06:39:54 +0800</pubDate>
        <link>/2015/12/25/chaos-to-vim/</link>
        <guid isPermaLink="true">/2015/12/25/chaos-to-vim/</guid>
        
        
        <category>programming</category>
        
        <category>Vim</category>
        
        <category>chaos</category>
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>机器学习2：常用算法入门小结</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;机器学习2：常用算法入门小结&lt;/h1&gt;

&lt;p&gt;匆匆刷过了著名的机器学习课程(link)，本文记录一下学习经验。当然，这篇文章的前几稿必定不很靠谱。不过，只有经过这些粗糙的文字，才能迭代出更精准的思考。请各位读者不吝赐教。&lt;/p&gt;

&lt;h2 id=&quot;supervised-learning&quot;&gt;有监督学习 supervised learning&lt;/h2&gt;

&lt;h3 id=&quot;linear-regression&quot;&gt;线性回归 linear regression&lt;/h3&gt;
&lt;p&gt;最基本的回归算法。优化对象是 &lt;code class=&quot;highlighter-rouge&quot;&gt;误差的平方和&lt;/code&gt;。 其实就是我们熟知的最小二乘法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：算法和实现极其简单；速度快；low-variance&lt;/li&gt;
  &lt;li&gt;缺点：只能处理线性关系；复杂关系时 high-bias&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;求解可用梯度下降(gradient descent)或者直接计算(normal equation)。前者需要参数归一化，后者对于大量样本计算量较大。&lt;/p&gt;

&lt;p&gt;延伸： 可添加高阶项和相互作用项，但可能遇到的问题是特征数量剧增(特别是相互作用项)。如5个特征的二次项就有5+10+5=20个；而100个特征的二次项就多达100+4950+100=5150个。另一个问题是特征过多可能造成过拟合，可引入正则化系数降低影响。&lt;/p&gt;

&lt;h3 id=&quot;logistic-regression&quot;&gt;逻辑回归 logistic regression&lt;/h3&gt;

&lt;p&gt;虽然名字里面有回归，但逻辑回归是一种分类算法。基于sigmoid函数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：相对简单，计算量小；可以给出概率解释；&lt;/li&gt;
  &lt;li&gt;缺点：只能进行线性分类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;neuron-network&quot;&gt;神经网络 neuron network&lt;/h3&gt;

&lt;p&gt;模拟神经元层级网络的算法结构。基础单元是单个节点，通过简单响应函数的组合可以学习复杂的变量关系（如从基本的与/或/非组成异或等复杂的逻辑关系）。多层的神经网络也被称为深度学习。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：可学习复杂的非线性关系&lt;/li&gt;
  &lt;li&gt;缺点：实现相对复杂；计算量大；结果的含义无法解释&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;support-vector-machine&quot;&gt;支持向量机 support vector machine&lt;/h3&gt;

&lt;p&gt;与前面的算法关注整体不同的是，支持向量机更关注分隔界面附近的样本，算法最大化分隔界面与附近的支持向量间的距离。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：通过核函数可学习非线性关系；&lt;/li&gt;
  &lt;li&gt;缺点：速度慢；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unsupervised-learning&quot;&gt;无监督学习 unsupervised learning&lt;/h2&gt;

&lt;h3 id=&quot;k-k-means&quot;&gt;k均值 k-means&lt;/h3&gt;

&lt;p&gt;cluster算法，把样本根据几何距离分成k组（因此各个特征一定要归一化）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点：易于理解；&lt;/li&gt;
  &lt;li&gt;缺点：只能按距离分组，对于其它类型数据的适应性差&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;principal-component-analysis&quot;&gt;主成分分析 principal component analysis&lt;/h3&gt;

&lt;p&gt;采用正交化变换，把原有数据转换为一组标准正交基，并且按照对方差贡献多少排序。通常前几个主成分就可以解释绝大部分的方差，因此主成分分析常用于减少特征数量（降维）。当数据简化为2-3维时，我们可以有效可视化，对样本产生整体的理解。（可视化在机器学习系统设计初期往往十分重要）&lt;/p&gt;

&lt;h3 id=&quot;collabrating-filtering&quot;&gt;协同过滤 collabrating filtering&lt;/h3&gt;

&lt;p&gt;常用于推荐系统(recommender system)。解决的问题是如何填充某些元素缺失的矩阵（如用户-评分矩阵）。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;小结：算法之外&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;特征&lt;/h3&gt;

&lt;p&gt;事实上，在很多机器学习问题之中，不同算法的表现大致相当，决定系统表现的关键往往是&lt;code class=&quot;highlighter-rouge&quot;&gt;特征设计&lt;/code&gt;。好的特征常比好的算法更重要。另一方面，由于算法大多基于成熟的算法包(如scikit-learn in python)，实际上选择算法并不需要太多时间。针对实际数据调参和特征设计是机器学习中的主要内容。&lt;/p&gt;

&lt;p&gt;那么，如何寻找好的特征呢？似乎并没有通用的方法，理解业务目标、理解数据、系统测试，也许是一些可行的方案。特征工程也许需要相当的实际工程经验。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;机器学习系统的评估&lt;/h3&gt;

&lt;p&gt;Andrew Ng 在课程中反复提到：机器学习任务中，最宝贵的资源是&lt;code class=&quot;highlighter-rouge&quot;&gt;工程师的时间&lt;/code&gt;。我们有必要通过各种评估方法，确认自己的算法正在正确的道路上前进。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可视化: 我们更擅长观察图形，而非数据，样本量大时更是如此。可视化是我们理解数据和算法效果的最佳工具。&lt;/li&gt;
  &lt;li&gt;cross validation: 为了避免过拟合，我们不应在机器学习过程中使用test set的数据。需要优化参数时，应从training set中分出部分数据(常用比例为training set: CV set: test set = 60%:20%:20%)。&lt;/li&gt;
  &lt;li&gt;learning curve: 通过比较 J(train) 和 J(test) ，我们可以判断算法是 high bias 还是 high vaviance。&lt;/li&gt;
  &lt;li&gt;ceiling analysis: 通过人工标记给出100%正确的中间结果，可判断算法系统流程(pipeline)中的短板。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些更复杂的算法，如基于决策树的随机森林/AdaBoost，等到有经验再来描述。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;reference:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Andrew Ng: coursera course&lt;/li&gt;
  &lt;li&gt;machine learning in action&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 20 Oct 2015 06:39:54 +0800</pubDate>
        <link>/2015/10/20/ml-algorithms/</link>
        <guid isPermaLink="true">/2015/10/20/ml-algorithms/</guid>
        
        
        <category>机器学习</category>
        
        <category>programming</category>
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>杂谈大道理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;缘起&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;听过了许多大道理, 我们为什么仍然过不好这一生?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;客观理性的反馈分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;结语&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;未尽的话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;缘起&lt;/h2&gt;

&lt;p&gt;许久没写, 最近精力有些分散, 时光匆匆流逝, 却感觉自己什么都没做, 不免有些焦虑和自责. 这篇文章的本意是借着记录最近的一些想法, 整理思绪, 也给自己补补能量.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;听过了许多大道理, 我们为什么仍然过不好这一生?&lt;/h2&gt;

&lt;p&gt;前一阵有一句话十分流行: “听过了许多大道理, 我们却仍然过不好这一生”. 这句话的流行, 在我看来, 更像是对当下盛行的成功学和心灵鸡汤的一种反省, 或许可以帮早已被大道理灌输得无感的年轻一代, 稍稍缓解一下心中的无力感.&lt;/p&gt;

&lt;p&gt;从 “听” 到 “做” , 字面上好像很自然就能完成, 但真正做到绝非易事. 
事实上, 把听到或者看到的事情”脑补”为已经完成, 或许是导致人类诸多痛苦的一个错觉.&lt;/p&gt;

&lt;p&gt;如果我们反过来想, 做什么不能帮我们过好这一生呢? 
我们很容易就会发现, 不论看多少”大道理”, 都不能直接促成我们的成长与变化, &lt;strong&gt;只有亲自行动才能产生新的结果&lt;/strong&gt;. 
虽然行动不一定能保证得到我们想要的结果, 但是可以确定, 不行动什么都不会发生.&lt;/p&gt;

&lt;p&gt;因此, 我们需要的绝不只是大道理, 还有行动的智慧.&lt;/p&gt;

&lt;p&gt;成功学和鸡汤让我们感觉”似乎是那么回事, 可是怎么就不好用呢?” 
一个可能的原因是它们只强调激动人心的结果, 而忽略了漫长而艰难的过程. 
哪怕简单到早晚刷牙, 按时吃药这种不需要任何才智就能完成的事情, 随着时间的推移, 也会变得不那么容易. 
最近我为了治疗慢性鼻炎, 只不过一天三次吃两种药, 就已经开始出现记忆混乱, 难以保证按时完成.&lt;/p&gt;

&lt;p&gt;如果我们受到外界影响, 竟然误以为生活的主体是成功和辉煌, 那么在我们把目光从那些让人心潮澎湃的文章中移开, 开始面对自己的现实生活的时候, 期望与现实就会产生巨大的心理落差.
而这些额外的焦虑, 本是完全可以避免的. 从这个角度来看, 成功学和鸡汤带给社会的是负和. 
所以, 我个人对待成功学和鸡汤的原则是 “尽量不看, 误入快关, 坚决不传”. 
这个策略不仅保护了自己的大脑少受骚扰, 让自己更快乐, 也是在对整个社会做贡献呢 :)&lt;/p&gt;

&lt;p&gt;那么, 有没有什么靠谱的手段能让我们有更多, 更好的行动呢?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/22994632/&quot;&gt;《成功，动机与目标 (Succeed: How we can reach our goals)》&lt;/a&gt; 这本书就是非常好的&lt;strong&gt;行动参考手册&lt;/strong&gt;. 
这里只简单提一个很有意思的概念: 执行意图(&lt;a href=&quot;https://en.wikipedia.org/wiki/Implementation_intention&quot;&gt;Implementation intention&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;执行意图, 通常是一个 “如果…就…” 的句式. 前半句是&lt;strong&gt;触发条件&lt;/strong&gt;(比如周一早上八点半), 后半句是&lt;strong&gt;具体行动&lt;/strong&gt;(计划这一周的工作). 执行意图的一大巧妙之处, 就在于它省去了思考和选择的过程, 而让我们直接采取具体行动.&lt;/p&gt;

&lt;p&gt;在需要行动的时候, 我们就要尽量避免其它分心的想法(想想去健身房前的那些让你止步的念头吧), 唯一有用的既不是瞻前顾后, 也不是抽象的思考, 而是现在就开始行动. 
想要学编程? 那就每天晚上看一段 mooc 视频, 然后打开编辑器写几行代码; 
想要写一本传世小说? 那就从每周末写一篇博客开始; 
想要有优雅的身材? 每周三次, 每次健身房一小时.&lt;/p&gt;

&lt;p&gt;从抽象的想法到具体的行动, 就是我们最需要的智慧. 执行意图 “触发条件 - 具体行动” 的思考方式, 让我们产生更多的具体行动, 也就带来更好的结果.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;客观理性的反馈分析&lt;/h2&gt;

&lt;p&gt;从经验中学习, 恐怕是人类智慧最重要的来源之一. 詹姆斯马奇的 &lt;a href=&quot;http://book.douban.com/subject/6687032/&quot;&gt;《经验的疆界》&lt;/a&gt; 也是我反复品味的”大道理”之作.&lt;/p&gt;

&lt;p&gt;最近看到一篇&lt;a href=&quot;http://www.douban.com/group/topic/20159977/&quot;&gt;彼得德鲁克的文章&lt;/a&gt;, 也看到了一个很值得尝试的”大道理”: &lt;strong&gt;每当做出重要决定或采取重要行动时, 你都可以事先记录下自己对结果的预期. 9到12个月后, 再将实际结果与自己的预期比较.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也许这句话中有两点值得品味: 第一, 目标是重要的事情; 第二, 事先记录下自己的预期. 一旦事先记录了预期, 留下了不可更改的客观印记, 就不会再用各种理由欺骗自己. 
没错, 我们的大脑是最容易被欺骗的(Munger’s book).&lt;/p&gt;

&lt;p&gt;这种方法(feedback analysis)让我们更关心事实是什么, 而不是我的印象是什么.&lt;/p&gt;

&lt;p&gt;对于自己最近的尝试, 已经都记录下来. 长时间周期的记录将会产生足够大的样本, 足以分析出很多&lt;strong&gt;基于事实&lt;/strong&gt;的结论.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;过好平凡而独特的这一生, 比听多少大道理重要得多.&lt;/p&gt;

&lt;p&gt;行动创造新的体验, 理性的反思则产生更好的体验.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;未尽的话&lt;/h2&gt;

&lt;p&gt;人类心灵的种种错觉与如何生活得更真实, 更快乐, 也是我个人非常感兴趣的领域, 今后会慢慢写下一些自己的笔记. 敬请期待 :)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Oct 2015 06:39:54 +0800</pubDate>
        <link>/2015/10/04/notes-of-long-term/</link>
        <guid isPermaLink="true">/2015/10/04/notes-of-long-term/</guid>
        
        
        <category>随笔</category>
        
        <category>思考</category>
        
      </item>
    
      <item>
        <title>Python 机器学习: 从0到1</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#python--01&quot; id=&quot;markdown-toc-python--01&quot;&gt;Python 机器学习: 从0到1&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;原理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;流程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;生态系统&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;第一个版本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;参考资料和补充阅读&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;python--01&quot;&gt;Python 机器学习: 从0到1&lt;/h1&gt;

&lt;p&gt;目标: 记录最近尝试机器学习的经历和关键节点, 让 &lt;code class=&quot;highlighter-rouge&quot;&gt;六个月前的自己&lt;/code&gt; 可以更顺利的上手机器学习.&lt;/p&gt;

&lt;p&gt;提纲:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原理&lt;/li&gt;
  &lt;li&gt;流程&lt;/li&gt;
  &lt;li&gt;生态系统&lt;/li&gt;
  &lt;li&gt;第一个版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;机器学习 (machine learning) 三问:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机器学习是什么?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;一段可以从已知数据中”学习”, 随后预测未知数据的算法.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先, 我们把一些数据(常被称为训练集, training set) 输入进算法, 算法会从这些数据中学习到一些规律; 随后, 我们把另外的数据(测试集, test set)输入学习后的算法, 算法会预测一些相关的结果.&lt;/p&gt;

&lt;p&gt;抽象: 我们有训练集 &lt;code class=&quot;highlighter-rouge&quot;&gt;X_train&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y_train&lt;/code&gt;, 测试集 &lt;code class=&quot;highlighter-rouge&quot;&gt;X_test&lt;/code&gt;. 机器学习, 即用 &lt;code class=&quot;highlighter-rouge&quot;&gt;X_train&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y_train&lt;/code&gt; 得到二者(可能的)关系, 再从 &lt;code class=&quot;highlighter-rouge&quot;&gt;X_test&lt;/code&gt; 预测 y_test 的过程.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为什么要用机器学习?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大量数据人类处理起来非常困难, 也不现实. 如果机器学习可以为我们处理这些数据, 就可能发挥出极大的作用. 如大量文本的 OCR, 自动语音识别, 根据购买记录为每个人推荐可能喜欢的商品等等.&lt;/p&gt;

&lt;p&gt;以及, 人工智能的梦想.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;怎么实现机器学习?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很多种算法, 很多种程序设计语言都可以进行机器学习工程实践.&lt;/p&gt;

&lt;p&gt;在 Python 中, 已有成熟的各类算法包, 其中最著名的是 &lt;a href=&quot;http://scikit-learn.org/stable/index.html&quot;&gt;scikit-learn&lt;/a&gt; 提供的各种常用算法的黑箱版本实现.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;流程&lt;/h2&gt;

&lt;p&gt;其实, 我们熟知的线性回归, 就是机器学习的一种方法. 在线性拟合之中, 我们先用已知数据作为训练集, 算法学习到的规律即为回归函数; 在此之后, 算法就可以对未知数据进行预测.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;算法设计&lt;/li&gt;
  &lt;li&gt;训练&lt;/li&gt;
  &lt;li&gt;预测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在真实的问题之中, 数据通常都不是已经整理好的 X, y, 而可能是各种各样的格式. 如 自然语言文本(最近参加的&lt;a href=&quot;http://tianchi.aliyun.com/competition/introduction.htm?spm=5176.100066.333.11.TaumTb&amp;amp;raceId=5&quot;&gt;天池 - 新浪微博互动预测大赛&lt;/a&gt;就是微博原始文本), 图片, 音频, 视频… 在开始设计算法之前, 我们要先整理数据, 甚至要先获得足够多的数据. 机器学习通常由以下几个过程组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获得数据&lt;/li&gt;
  &lt;li&gt;整理数据&lt;/li&gt;
  &lt;li&gt;算法设计&lt;/li&gt;
  &lt;li&gt;训练与算法优化&lt;/li&gt;
  &lt;li&gt;预测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我上手的过程中, 发现一开始的困难, 多半是在各个部分的 i/o 接口之中, 而非算法设计. (因为算法使用 scikit-learn 提供的黑箱模型, 实际上不需要设计和测试算法本身.) 而在后期, 逐渐发现不同算法在数据量足够大时结果相近, 真正的难点往往是寻找合适的特征(feature), 微博的算法实践也初步证实了这一点.&lt;/p&gt;

&lt;p&gt;如果想让自己的机器学习 demo 尽快跑起来(从而获得反馈), 就需要先初步理解这个流程中用到的 Python 科学计算生态系统, 明白每一步的 i/o 接口如何设计.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;生态系统&lt;/h2&gt;

&lt;p&gt;Python 的科学计算生态系统主要包括: NumPy, SciPy, matplotlib, scikit-learn, pandas, …&lt;/p&gt;

&lt;p&gt;这里我们的目标不是详尽介绍 Python 科学计算, 而是简单描述相关的数据结构, 从而尽快搭起可用的机器学习算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NumPy: 提供多维数组&lt;/li&gt;
  &lt;li&gt;SciPy: 稀疏矩阵&lt;/li&gt;
  &lt;li&gt;matplotlib: 可视化&lt;/li&gt;
  &lt;li&gt;scikit-learn: 机器学习算法包, 提供各种常用算法的黑箱模型. 也就是说, 作为用户, 不必关心实现细节, 只要把数据送进来就好了.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NumPy, SciPy 等包都提供了非常详尽的官方文档, stackoverflow 中也有足够多的前人问题(至少我查过的问题, 诸如如何合并矩阵等, 都已经有人问过了XD), 因此善用 google, 耐心测试, 一般的问题均可解决.&lt;/p&gt;

&lt;p&gt;那么, 我们需要把什么数据格式送到 scikit-learn 中呢?&lt;/p&gt;

&lt;p&gt;实际上只需要送两个变量 X, y&lt;/p&gt;

&lt;p&gt;X 是 m*n 矩阵(数据结构是二维数组/嵌套列表), 其中 m 是样本数量, n 是特征数量;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常用格式为 numpy.ndarray&lt;/li&gt;
  &lt;li&gt;通常可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;type(X)&lt;/code&gt; 输出判断 X 的格式是否正确; 用 &lt;code class=&quot;highlighter-rouge&quot;&gt;X.shape&lt;/code&gt; (对于 numpy.ndarray 和 稀疏矩阵应都可用) 判断 X 的维度是否正确&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调整格式/feature合并/样本合并等常用 data cleanup 操作:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先用 type() 确认需要调整的矩阵格式&lt;/li&gt;
  &lt;li&gt;对于 numpy ndarray: np.concatenate(list, axis)&lt;/li&gt;
  &lt;li&gt;对于 scipy.sparse: sp.vstack/sp.hstack&lt;/li&gt;
  &lt;li&gt;debug/troubleshoot: 使用 X.shape 即可确认操作是否正确&lt;/li&gt;
  &lt;li&gt;scipy.io 提供 loadmat()/savemat() 可用于存储 feature 到文件备用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;y 是一维列表(注意, 机器学习中常把 y 用列向量表示, 但在 numpy 和 scikit-learn 中则通常用行向量/列表表示 y, 如果用列向量输入会得到 warning, 但程序会自动转换)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于 NumPy 的 一维列向量列表对象 y, 可用 y.ravel() 方法把 y 转为 行向量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;第一个版本&lt;/h2&gt;

&lt;p&gt;从线性回归 &lt;a href=&quot;http://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html#example-linear-model-plot-ols-py&quot;&gt;Linear Regression Example&lt;/a&gt; 开始吧&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
from sklearn import linear_model
clf = linear_model.LinearRegression()
clf.fit ([[0, 0], [1, 1], [2, 2]], [0, 1, 2]) # x是 m*n 矩阵(数据结构是二维数组/嵌套列表), m是样本数量 (3) , n 是特征数量 (2), ; y 是一维列表(注意, 机器学习中常把 y 用向量表示)
LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)
clf.coef_ # 模型中各参数的值
array([ 0.5,  0.5])
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;scikit-learn 中最常用的方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fit(X, y)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;predict(X)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说, 只要整理好数据, 只需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;选择模型, fit, predict&lt;/code&gt; 三步就完成了机器学习过程. scikit-learn 就是这么轻松愉快 :)&lt;/p&gt;

&lt;p&gt;各种模型基本都通用, 可在 api 中查具体模型的对应方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://scikit-learn.org/stable/tutorial/basic/tutorial.html#model-persistence&quot;&gt;模型保存和读取&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;```python
from sklearn.externals import joblib
joblib.dump(clf, ‘filename.pkl’)&lt;/p&gt;

&lt;p&gt;clf = joblib.load(‘filename.pkl’) 
```&lt;/p&gt;

&lt;p&gt;注: 如此存储时 .pkl文件还会带有同样名字的几个其它文件 .npy 等, 不要误删.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;看上去高大上的机器学习, 在 Python 中已有很多很好的相关开源工具. 上手使用的难度并不大, 新手也可以很快构建出自己的算法雏形. 用 Python 做机器学习值得安利给大家:)&lt;/p&gt;

&lt;p&gt;从0到1的学习过程中, 遇到的困难大多来自于 i/o 接口. 对 i/o 的关注也许是一直需要的.&lt;/p&gt;

&lt;p&gt;入门虽易, 但得到一个效果出色的机器学习算法, 往往需要大量尝试(这方面, 机器学习与日常科研中做实验非常像). 后面, 就要遇到实际的工程问题了.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考资料和补充阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning&quot;&gt;斯坦福大学 Angrew Ng 的机器学习课程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/67616/&quot;&gt;有趣的机器学习：最简明入门指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Sep 2015 22:30:00 +0800</pubDate>
        <link>/2015/09/12/chaos-to-machine-learning/</link>
        <guid isPermaLink="true">/2015/09/12/chaos-to-machine-learning/</guid>
        
        
        <category>机器学习</category>
        
        <category>Python</category>
        
        <category>chaos</category>
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>为什么公开讨论令众受益?</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;缘起&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;信息流&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;群体与个体&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;小结&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#changelog&quot; id=&quot;markdown-toc-changelog&quot;&gt;Changelog&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;缘起&lt;/h2&gt;

&lt;p&gt;和大妈讨论问题中, 大妈苏格拉底式的提问: &lt;code class=&quot;highlighter-rouge&quot;&gt;为什么应该 公开讨论令众受益?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;简短思考后, 尝试作答, 大妈再次提点 &lt;code class=&quot;highlighter-rouge&quot;&gt;嗯哼,忘记 公开讨论令众受益了?&lt;/code&gt; 于是写下这篇短文, 把这段思考公开.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;信息流&lt;/h2&gt;

&lt;p&gt;信息流动与金钱流动有一点不同: 金钱流动中, 得/失必然相等, 是零和过程, 总和不变; 而信息流动中, 信息发出方不会因为信息传递失去信息, 是正和过程, 总和增加.&lt;/p&gt;

&lt;p&gt;因此, 高质量的信息流动有益于群体. (另一方面, 低质量的信息流动则对群体不利.)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;群体与个体&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;公开讨论&lt;/code&gt;中, 群体和个体在信息流动时, 发生了两个方面的相互作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;正向 &lt;code class=&quot;highlighter-rouge&quot;&gt;个体-&amp;gt;群体&lt;/code&gt;: 群体从个体公开化输出的信息流中, 吸收个体的独特思考而获益;&lt;/li&gt;
  &lt;li&gt;反向 &lt;code class=&quot;highlighter-rouge&quot;&gt;群体-&amp;gt;个体&lt;/code&gt;: 个体也从群体的反馈中, 弥补自己的思维盲区.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 信息的发出方和接收方都会从中受益.&lt;/p&gt;

&lt;p&gt;可能的深层来源:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;个体差异: 每个人有独特的经验;&lt;/li&gt;
  &lt;li&gt;个体相似性: 个体的独特经验大多可被他人复用.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;公开讨论令众受益:)&lt;/p&gt;

&lt;p&gt;看到这里, 你最近有什么值得公开的讨论吗? 不妨分享出来 XD&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;changelog&quot;&gt;Changelog&lt;/h3&gt;

&lt;p&gt;需要补全的内容:&lt;/p&gt;

&lt;p&gt;定义每个概念: 什么是公开讨论, 众是谁, 包括自己吗?&lt;/p&gt;

&lt;p&gt;足以让 &lt;code class=&quot;highlighter-rouge&quot;&gt;六个月前的自己&lt;/code&gt; 明白这里讨论的始末, 也就可以分享给他人了.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Sep 2015 06:11:54 +0800</pubDate>
        <link>/2015/09/03/discuss-public/</link>
        <guid isPermaLink="true">/2015/09/03/discuss-public/</guid>
        
        
        <category>随笔</category>
        
        <category>思考</category>
        
      </item>
    
      <item>
        <title>返场: 理性的理性反思</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;无限成长的智识疆域&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;拾遗:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们讨论了生活中缺乏理性引起的很多问题, 也讨论了理性的”正确打开方式”, 那么理性是万能灵药吗?&lt;/p&gt;

&lt;p&gt;一个理性的回答: 很遗憾, 不是.&lt;/p&gt;

&lt;p&gt;并且, 当我们用理性反思理性, 会发现理性并不认为自己具有唯一的合法性. 并且特别的是, 理性强调自身的不完美(与各种宗教和神秘主义相反)—-承认自己的局限其实是最大的理性.&lt;/p&gt;

&lt;p&gt;实际问题中, “有用”是最重要的. 实际生活中，我们需要完备性（分析所有的已知和未知），不能因为问题在理性疆域之外 (比如一个长着老虎头和狮子身体的未知动物突然出现在我们面前) 就置之不理.&lt;/p&gt;

&lt;p&gt;一个有用的方案未必是一致的——不必刻意追求模型/机制的一致性/大统一.
一致当然很美，也很好，但是最重要的目标是有用; 不断迭代的思路也许既可行又好用.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;无限成长的智识疆域&lt;/h2&gt;
&lt;p&gt;而从另一个角度来看, 理性证明自己局限的同时, 也产生了一个更大的梦想: 人类有一个可以不断拓展的智识疆域——这也许就是不一致带给我们的无限的可能性. (如果一切问题都可以按照某个特别的方法解决, 那么我们的创造性也就消失了.)&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;拾遗:&lt;/h3&gt;

&lt;p&gt;理性思维的专长在于系统性纠错和避免错误. 并不长于产生新的想法. 如果想找通向终点的直线道路, &lt;a href=&quot;https://en.wikipedia.org/wiki/TRIZ&quot;&gt;TRIZ&lt;/a&gt; 中的 ideal final result（最终理想解）是个更好的概念&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Aug 2015 07:21:54 +0800</pubDate>
        <link>/2015/08/23/limit-of-rationality/</link>
        <guid isPermaLink="true">/2015/08/23/limit-of-rationality/</guid>
        
        
        <category>写给十年前的自己</category>
        
        <category>理性之心</category>
        
        <category>随笔</category>
        
      </item>
    
      <item>
        <title>模型与机制</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;模型与机制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;模型: 相关的集合&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;机制: 因果的序列&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;模型与机制&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;All models are wrong, but some are useful.&lt;/em&gt;—-George Box and Norman Draper&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型: 相关的集合&lt;/h2&gt;

&lt;p&gt;模型 (model) 是事物的简化, 通常是很多组相关的集合. 比如在中学物理课中, 我们总是把运动的物体画成一个小方块, 甚至还可以进一步简化为一个神奇的点–质点.&lt;/p&gt;

&lt;p&gt;模型的作用是信息压缩. 万事万物中的联系, 哪些比较重要? 模型可以告诉我们, 对于A, xyz与之相关: 考试的成绩主要与我们的学习情况有关, 而不是今天穿了哪双鞋或者用了哪根笔… 更进一步还可以定量化, 也许x比yz 更加重要…&lt;/p&gt;

&lt;p&gt;永远不要试图建立完美的模型, 而是去建立有用的模型, 再不断迭代, 抛弃不符合事实的模型. 要用开放的心态, 不断接受新的事实—建模和生活都是如此.&lt;/p&gt;

&lt;p&gt;很多时候, 我们沉醉于优美的模型之中, 而忽略了复杂的真实世界. 正态分布是一个典型的例子. 它具有很好的数学性质, 在 3sigma 之外的事件发生概率很低, 通常不会对整体带来很大影响. 然而, 在真实世界中, 小概率事件发生后时常并不会自行消亡, 甚至可能引起极其严重的后果. 比如, 2008年次贷危机爆发后全球都陷入经济危机. 此类事件并不符合正态分布, 而应该用幂律分布来描述. 幂律分布的模型中, 少数几次小概率事件就可能对整体产生极其巨大的影响. (一个典型的例子是, 20% 最富有的人拥有80% 以上的财富.)&lt;/p&gt;

&lt;p&gt;另外值得注意的是, &lt;strong&gt;压缩信息通常伴随着信息的损失&lt;/strong&gt;. 比如, 当我们用两个事物的比例(a/b一维)代替它们的总量(a, b 二维)时, 就失去了绝对数量的信息, 导致 &lt;a href=&quot;https://en.wikipedia.org/wiki/Simpson%27s_paradox&quot;&gt;Simpson’s paradox&lt;/a&gt; 的产生.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;机制: 因果的序列&lt;/h2&gt;

&lt;p&gt;机制是因果的序列, 在这个序列之中, 每一个因果关系都要是正确的. 在几何中, 我们通过一连串因果, 可以把看似不相关的两个命题串联起来. 不过, 这样优雅的演绎推理, 在现实生活中可能并不常见.&lt;/p&gt;

&lt;p&gt;个人感觉我们的大脑过分”爱好”因果了. 这也许和我们倾向于找到一个“解释”或者“故事”的思维假定（认知倾向）有关. 真正可靠的机制, 比我们想象之中的要少很多. 我们时常的联想, “我要是做了a, 就能b-c-d……” 仔细分析起来, 通常并不那么靠谱.(当然, 我们归因的偏好一直存在, 也没必要强迫自己不去想. 只是在重要的事情上, 应当用理性仔细分析机制中每一环的因果关系是否可靠.)&lt;/p&gt;

&lt;p&gt;机制的作用——&lt;strong&gt;预知&lt;/strong&gt;. 正确的机制使我们能够未雨绸缪, 站在时间的源头看到未来, 从而做出更好的选择. 预见未来, 也是人类对于”智慧”的终极定义之一.&lt;/p&gt;

&lt;p&gt;另外, 值得我们注意的是: 第一, 因果只关心充分性，并不能保证必要性——也就是说，只能说明abc-&amp;gt;A，不能证明A的产生一定会有abc; 第二, 现实生活的任何机制都要面临不确定性——不要试图找到一个确定正确的机制, 达到“有用”的置信度就可以了.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Aug 2015 07:21:54 +0800</pubDate>
        <link>/2015/08/21/model-and-mechanism/</link>
        <guid isPermaLink="true">/2015/08/21/model-and-mechanism/</guid>
        
        
        <category>写给十年前的自己</category>
        
        <category>理性之心</category>
        
      </item>
    
      <item>
        <title>概念与定义</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;概念与定义&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;概念: 一个神奇的黑盒子&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;理性定义概念&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;概念与定义&lt;/h1&gt;

&lt;p&gt;前面我们讨论了理性和语言. 我们在日常生活中说的话时常并不那么准确, 甚至常有”强词夺理”之嫌. 那么, 如果我们想把可重复的理性带到自己的生活之中, 应该怎么尝试呢? 理性的分析与讨论, 就从定义话语中的每一个概念开始.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概念: 一个神奇的黑盒子&lt;/h2&gt;

&lt;p&gt;为了描述复杂的世界, 人类发明了无数&lt;strong&gt;概念&lt;/strong&gt;. 概念可以大致理解成一个黑盒子, 有它自身的范围, 可以判断某个对象是否属于其中.&lt;/p&gt;

&lt;p&gt;模糊的自然语言之中, 同一个概念的含义也时常多变. 比如, 茶杯的 ”安全” 和一辆车的 ”安全” 并不是一个含义. 前者可能是指茶杯不容易打碎, 后者则是指车中的乘客的人身安全. 因此, 想要精确地定义或理解概念时, 我们时常需要分析概念所处的具体语境.&lt;/p&gt;

&lt;p&gt;很多似是而非的 ”问题”, 也来自于概念的模糊不清. 知乎上有一个问题: 很多 ”聪明人”为什么不成功？对这句话的分析, 可以从分析话语中的两个概念—- ”聪明” 和 ”成功” 开始[1].&lt;/p&gt;

&lt;p&gt;在此处的 “聪明” 通常是指&lt;strong&gt;做事快&lt;/strong&gt;; 而成功, 成就则是指完成别人难以完成的事情—-有的时候是超出常人的速度, 但更多的时候, 则是比较完成事情的质量（如写一本长篇小说时，我们并不关注写作时间长短, 而是最终作品的质量高低）.&lt;/p&gt;

&lt;p&gt;当我们定义出这两个概念的轮廓与交集, 再继续讨论下去就非常方便. 做事的质量和快慢没有直接联系, “聪明人” 在需要做事快的时候可能容易成功, 但对于更多的事情来说, 他们可能未必有特别的优势, 因此, 很多聪明人不成功, 实际上并不奇怪.&lt;/p&gt;

&lt;p&gt;而我们刚看到这个问题时, 感觉似乎有点别扭, 是因为我们的第一反应并不是理性定义这两个概念. “聪明”作为一个褒义词, 使我们产生了一种正面的想象; 但当这个正面的情绪和 “不成功” 联系起来时, 我们的情绪反应就会有些不一致. 这就是概念(语言)的情感力量.&lt;/p&gt;

&lt;p&gt;当几个概念被一起使用时, 它们的情感力量会互相作用, 从而影响我们的判断. 广告就是一个最典型的例子. 把产品和美好的事物放在一起出现时, 我们会自然地产生一种和谐的联想—-这个产品也是美好的(当然, 真相究竟如何, 是另一个问题).&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;理性定义概念&lt;/h2&gt;

&lt;p&gt;概念是我们使用语言的最小单位. 而当我们希望自己说的话可以准确表达某种特定的意思时, 小心使用概念就非常重要. 我们想表达的范围有多大? 这个概念有没有附加的情感含义? 别人听到这个概念的时候, 他们的理解是我们希望的吗?&lt;/p&gt;

&lt;p&gt;这里对概念与定义的讨论, 只是进一步指出日常生活中我们的一些困惑, 实际上来源于混乱的概念与定义[2]. 而我们想要理性讨论问题时, 相对准确的概念则是一个必要的出发点.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;另一种对这个问题的看法是观察者偏见. 即聪明人不成功的比例并不显著高于人群整体, 但因为观察的人更多地注意到了聪明人, 就更多地注意到了不成功的聪明人, 会产生不成功的聪明人很多的感觉.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在自然语言的模糊背景下, 我们也许并不能建立出一套完美精确的概念体系. 事实上, 即使在使用精确数学语言的集合论中, 清晰定义概念范围—-集合边界的尝试(&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AD%96%E6%A2%85%E6%B4%9B-%E5%BC%97%E5%85%B0%E5%85%8B%E5%B0%94%E9%9B%86%E5%90%88%E8%AE%BA&quot;&gt;策梅洛-弗兰克尔集合论&lt;/a&gt;)也并不那么成功.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本&lt;span xmlns:dct=&quot;http://purl.org/dc/terms/&quot; href=&quot;http://purl.org/dc/dcmitype/Text&quot; rel=&quot;dct:type&quot;&gt;作品&lt;/span&gt;采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Aug 2015 07:21:54 +0800</pubDate>
        <link>/2015/08/10/concept-and-definition/</link>
        <guid isPermaLink="true">/2015/08/10/concept-and-definition/</guid>
        
        
        <category>写给十年前的自己</category>
        
        <category>理性之心</category>
        
      </item>
    
      <item>
        <title>argparse - Python standard library</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#argparse---python-standard-library&quot; id=&quot;markdown-toc-argparse---python-standard-library&quot;&gt;argparse - Python standard library&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#outline&quot; id=&quot;markdown-toc-outline&quot;&gt;Outline&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#why-argparse--argparse-&quot; id=&quot;markdown-toc-why-argparse--argparse-&quot;&gt;why argparse? 为何要学 argparse 模块?&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;为什么要用参数?&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;怎么接受参数比较好?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#how-to-begin-&quot; id=&quot;markdown-toc-how-to-begin-&quot;&gt;how to begin? 怎么上手?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;argparse---python-standard-library&quot;&gt;argparse - Python standard library&lt;/h1&gt;

&lt;h2 id=&quot;outline&quot;&gt;Outline&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;why argparse? 为什么要用?&lt;/li&gt;
  &lt;li&gt;how to begin? 怎么上手?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-argparse--argparse-&quot;&gt;why argparse? 为何要学 argparse 模块?&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;为什么要用参数?&lt;/h3&gt;

&lt;p&gt;对于一个能完成特定功能的程序, 直接用命令行调用最为简单(相对于进入之后大量的用户 i/o 来说). 因此通过一串参数表明调用程序的功能, 也是一种最常用的模式(几个月前的自己还觉得一堆命令参数很麻烦, 现在就已经入坑了XD).&lt;/p&gt;

&lt;p&gt;如同一个好的函数通常用参数来接受输入, 一个好的程序也应当通过命令行参数来接受输入. 这样的交互优点可能有: 更易于使用和自动化调用; 更容易控制用户的输入输出.&lt;/p&gt;

&lt;p&gt;具体的例子: 在 GitBook auto summary 和 orglab/mahjong 早期开发中, 均使用了 rawinput/input 函数在程序内接受用户输入. 如果想要进一步自动化操作(如定期自动导出), 就需要设法在程序内模拟用户输入. 这在技术上麻烦了很多, 不如直接在命令行接受参数作为输入. 因此, 后期都增加了相应的功能.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;怎么接受参数比较好?&lt;/h3&gt;
&lt;p&gt;对于这两个程序, 因结构比较简单, 参数数量也少. 直接手动写接受参数也可行(初期直接用 sys.argv unpack实现). 但有以下问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可能自己的实现中有 bug&lt;/li&gt;
  &lt;li&gt;长期写程序时复用性如何?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浏览 python doc 时看到 argparse 的入门教程(tutorial)[1]. 于是用最简方法应用到自己的 Gitbook auto summary 仓库之中.&lt;/p&gt;

&lt;h2 id=&quot;how-to-begin-&quot;&gt;how to begin? 怎么上手?&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;argparse&lt;/code&gt; module makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and argparse will figure out how to parse those out of sys.argv. The argparse module also automatically generates help and usage messages and issues errors when users give the program invalid arguments. [2]&lt;/p&gt;

&lt;p&gt;简单来说, argparse 可以帮助我们很容易的写出命令行交互界面(command-line interface), 并且可以自动生成很好的注释, 帮助及错误处理, 便于程序被大家(和自己)使用.&lt;/p&gt;

&lt;p&gt;在 GitBook auto summary (commit &lt;a href=&quot;https://github.com/Frank-the-Obscure/GitBook-auto-summary/commit/5005ebf8c1baeb4a093ec263d6a3ad87ff5cc42d&quot;&gt;5005eb&lt;/a&gt;) 中的相关代码和注释&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python
parser = argparse.ArgumentParser()
parser.add_argument(&#39;-o&#39;, &#39;--overwrite&#39;, help=&#39;overwrite on SUMMARY.md&#39;, 
                    action=&quot;store_true&quot;) # 定义 overwrite 参数
parser.add_argument(&#39;directory&#39;, help=&#39;the directory of your GitBook root&#39;) # 定义 directory 参数
args = parser.parse_args() # Convert argument strings to objects and assign them as attributes of the namespace. Return the populated namespace.
overwrite = args.overwrite
dir_input = args.directory
if args.overwrite:
    print(dir_input, &#39;overwrite&#39;)
else:
    print(dir_input)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MVP:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;argparse.ArgumentParser()&lt;/li&gt;
  &lt;li&gt;ArgumentParser.add_argument()&lt;/li&gt;
  &lt;li&gt;ArgumentParser.parse_args()&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;References&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/howto/argparse.html&quot;&gt;Argparse Tutorial&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/argparse.html&quot;&gt;argparse - py std lib&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 02 Aug 2015 07:21:54 +0800</pubDate>
        <link>/2015/08/02/argparse/</link>
        <guid isPermaLink="true">/2015/08/02/argparse/</guid>
        
        
        <category>Programming</category>
        
        <category>Python</category>
        
        <category>笔记</category>
        
      </item>
    
  </channel>
</rss>
